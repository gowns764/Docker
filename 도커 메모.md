# 도커 명령어 정리
    docker <명령>
- 항상 root 권한으로 실행해야 한다.

## 1. search
    docker search
- 도커 허브에서 이미지를 검색할 수 있다.

## 2. pull
    docker pull <이미지 이름>:<태그>
- 도커 허브에서 이미지를 받는다.
  - 이미지 이름에서 *pyrasis/ubuntu*처럼 / 앞에 사용자명을 지정하면, 도커 허브에서 해다 사용자가 올린 이미지를 받는다.
  - 태그에서 *latest*를 설정하면 최신 버전을 받는다.
    - 특정 버전을 지정할 수 있다.

## 3. images
    docker images
- 받은 모든 이미지 목록을 출력한다.
- *docker images ubuntu*처럼 이미지 이름을 설정하면, 그 이미지가 출력된다.

## 4. run
    docker run <옵션> <이미지 이름> <실행할 파일>
- 컨테이너를 생성한다.
### 4.1. 옵션
- *-i*, *-t* 옵션을 사용하면 실행된 콘솔에서 입출력을 할 수 있다.
  - *exit*을 입력하여 Bash 셸에서 빠져나올 수 있다.
- *--name* 옵션으로 컨테이너의 이름을 지정할 수 있다.
  - 이름을 지정하지 않으면 도커가 자동으로 이름을 생성하여 지정한다.
- *-d* 옵션은 컨테이너를 백그라운드로 실행한다.
- *-p <호스트 포트>:<컨테이너 포트>* 옵션으로 호스트의 포트와 컨테이너의 포트를 연결하고, 외부에 노출한다.
- *--expose <컨테이너 포트>* 옵션은 다른 컨테이너에서 해당 컨테이너 포트에 연결할 수 있도록 설정한다.
  - *-p* 옵션과는 달리, 호스트의 포트를 외부에 노출하지 않는다.
- *-v <호스트 디렉토리>:<컨테이너 디렉토리>* 옵션은 호스트와 컨테이너가 디렉토리를 공유할 수 있게 한다.
  -  호스트의 디렉토리를 컨테이너의 디렉토리에 연결한다.
  -  *-v <컨테이너 디렉토리>* 옵션은 컨테이너 디렉토리를 데이터 볼륨으로 설정한다.
- *--link <컨테이너 이름>:<별칭>* 옵션으로 컨테이너끼리 연결할 수 있다.
  - 이 옵션은 *network create* 명령으로 네트워크 생성후 *--network* 옵션으로 대체 가능하다.
- *--network* 옵션은 컨테이너들을 한 네트워크에 연결시킨다.
- *--rm* 옵션은 컨테이너를 실행만 하고, 컨테이너 자체는 삭제한다. (1회성 사용)
- *--volumes-from <데이터 볼륨 컨테이너>* 옵션은 데이터 볼륨 컨테이너를 연결한다.
- *--privileged* 옵션은 컨테이너 안에서 호스트의 리눅스 커널 기능을 모두 사용할 수 있도록 한다.
- *--entrypoint="<명령>"* 옵션을 사용하면, Dockerfile에서 설정한 ENTRYPOINT는 무시된다.
- *-e <환경변수>=<값>* 옵션은 환경변수를 설정한다.
  - 이 옵션은 여러 번 사용할 수 있다.
  - *--env* 옵션과 같다.

## 5. ps
    docker ps
- 모든 컨테이너 목록을 출력한다.
- *-a* 옵션을 사용하면 정지된 컨테이너까지 모두 출력한다.

## 6. start
    docker start <컨테이너 이름>
- 컨테이너를 실행한다.

## 7. restart
    docker restart <컨테이너 이름>
- 컨테이너를 재시작 한다.

## 8. attach
    docker attach <컨테이너 이름>
- 실행한 컨테이너에 접속한다.

## 9. exec
    docker exec <컨테이너 이름> <명령> <매개 변수>
- 외부에서 컨테이너 안의 명령을 실행한다.
- 컨테이너가 실행되고 있는 상태에서만 사용할 수 있으며, 정지된 상태에서는 사용할 수 없다.
- 이미 실행된 컨테이너에 apt-get, yum 등의 명령으로 패키지를 설치하거나, 데몬을 실행할 때 활용할 수 있다.

## 10. stop
    docker stop <컨테이너 이름>
- 컨테이너를 정지한다.

## 11. rm
    dockler rm <컨테이너 이름>
- 생성된 컨테이너를 삭제한다.

## 12. rmi
    docker rmi <이미지 이름>:<태그>
- 이미지를 삭제한다.
- 태그를 지정하지 않으면, 태그는 다르지만 같은 이름을 가진 모든 이미지가 삭제된다.

## 13. history
    docker history <이미지 이름>:<태그>
- 이미지의 히스토리를 조회한다.

## 14. cp
    docker cp <컨테이너 이름>:<경로> <호스트 경로>
- 컨테이너에서 호스트로 경로 파일을 복사한다.

## 15. commit
    docker commit <옵션> <컨테이너 이름> <이미지 이름>:<태그>
- 컨테이너의 변경 사항을 이미지 파일로 생성한다.
- 이 명령으로 이미지를 생성해도 데이터 볼륨의 변경 사항은 이미지에 포함되지 않는다.
  - 데이터 볼륨 데이터를 컨테이너가 아닌 호스트에 저장하는 방식이다.
  - 컨테이너 끼리 데이터를 공유할 때 활용한다.

## 16. diff
    docker diff <컨테이너 이름>
- 컨테이너가 실행되면서 변경된 파일 목록을 출력한다.
  - 출력 내용에서 A는 추가된 파일, C는 변경된 파일, D는 삭제된 파일이다.

## 17. inspect
    docker inspect <이미지 또는 컨테이너 이름>
- 이미지나 컨테이너의 세부 정보를 출력한다.

## 18. push
    docker push <Docker 레지스트리 URL>/<이미지 이름>:<태그>
- 레지스트리 서버에 이미지를 올린다.
- 저장소에 이미지를 올리기 전에 태그를 먼저 생성해야 한다.

## 19. tag
    docker tag <이미지 이름>:<태그> <docker 레지스트리 URL>/<이미지 이름>:<태그>
- 태그를 생성한다.

## 20. network create
    docker network create <생성할 네트워크 이름>
- 네트워크를 생성한다.
- 네트워크를 생성하고 컨테이너를 연결시키면, 해당 네트워크 안에 속한 컨테이너들은 서로 접속할 수 있다.

## 21. build
    docker build <옵션> <Dockerfile 경로>
- 이미지를 생성한다.
- *--tag* 옵션으로 이미지 이름과 태그를 설정할 수 있다.
- *--no--cache* 옵션으로 캐시된 결과를 사용하지 않을 수 있다.

# Dockerfile
    <명령> <매개변수>
- #은 주석, 명령은 대소문자를 구분하지 않지만 일반적으로 대문자로 작성한다.
- 명령은 항상 *FROM*으로 시작해야 한다.
- 각 명령은 독립적으로 실행된다.

## .dockerignore
- 컨텍스트에서 파일이나 디렉토리를 제외할 때 사용하는 파일이다.
  - 컨텍스트는 Dockerfile과 같은 디렉토리에 들어있는 모든 파일이다.
  - 이미지를 생성할 때 모든 컨텍스트를 도커 데몬에 전송하므로, 필요 없는 파일이 포함되지 않도록 주의한다.
- Docker는 Go언어로 작성되어 있기 때문에, 파일 매칭도 Go언어의 규칙을 따른다.
- *을 사용하여 특정 파일이나 디렉토리를 제외할 수 있다.
- 버전 관리 시스템을 이용하여 Dockerfile과 필요한 파일을 관리할 때, .git과 .svn과 같은 디렉토리를 제외한다.

## 1. FROM
    FROM <이미지> 또는 FROM <이미지>:<태그>
- 어떤 이미지를 기반으로 이미지를 생성할지 설정한다.
  - Dockerfile로 이미지를 생성할 때는 항상 기존에 있는 이미지를 기반으로 생성한다.
- 이미지 이름과 태그를 함께 설정할 수도 있다.
- Dockerfile 하나에 FROM을 여러 개 설정할 수 있다.
  - 이 경우에 이미지가 두 개 생성된다.

## 2. MAINTAINER
    MAINTAINER <작성자 정보>
- 이미지를 생성한 사람의 정보를 설정한다.
  - 형식은 자유이며, 보통 이름과 이메일을 입력한다.
- MAINTAINER는 생략할 수 있다.

## 3. RUN
- FROM에서 설정한 이미지 위에서 스크립트나 명령을 실행한다.
  - RUN으로 실행한 결과가 새 이미지로 생성되고, 실행 내역은 이미지의 히스토리에 기록된다.

### 3.1. 셸(/bin/sh)로 명령 실행하기
    RUN <명령>
- 셸 스크립트 구문을 사용할 수 있다.
- FROM으로 설정한 이미지에 포함된 /bin/sh 실행 파일을 사용하게 되며, /bin/sh 실행 파일이 없으면 사용할 수 없다.

### 3.2. 셸 없이 바로 실행하기
    RUN ["<실행 파일>", "<매개변수1>", "<매개변수2>"]
- 실행 파일과 매개변수를 배열 형태로 설정한다.
- FROM으로 설정한 이미지의 /bin/sh 실행 파일을 사용하지 않는 방식이다.
  - 셸 스크립트 문법이 인식되지 않으므로, 셸 스크립트 문법과 관련된 문자를 그대로 실행 파일에 넘겨줄 수 있다.
- RUN으로 실행한 결과는 캐시되며, 다음 빌드 때 재사용한다.
    - 캐시된 결과를 사용하지 않으려면, *docker build* 명령에서 *--no--cache* 옵션을 사용하면 된다.

## 4. CMD
- 컨테이너가 시작되었을 때, 스크립트나 명령을 실행한다.
  - *docker run*이나 *docker start* 명령을 실행항 때 실행된다.

### 4.1. 셸로 명령 실행하기
    CMD <명령>
- 셸 스크립트 구문을 사용할 수 있다.

### 4.2. 셸 없이 바로 사용하기

### 4.2.1. 셸 없이 바로 실행할 때 매개변수 설정하기
    CMD ["<실행 파일>", "<매개변수1>", "<매개변수2>", ...]
- 실행 파일과 매개변수를 배열 형태로 설정한다.

### 4.2.2. ENTRYPOINT를 사용하였을 때
    CMD ["<매개변수1>", "<매개변수2>", ...]
- *ENTRYOINT*에 설정할 명령에 매개변수를 전달하여 실행한다.
- ENTRYPOINT가 있으면 CMD는 ENTRYPOINT에 매개변수만 전달하는 역할을 한다.
  - CMD는 독자적으로 파일을 실행할 수 없게 된다.

## 5. ENTRYPOINT
- 컨테이너가 시작되었을 때, 스크립트나 명령을 실핸한다.
- Dockerfile에서 단 한 번만 사용할 수 있다.

### 5.1. 셸로 명령 실행하기
    ENTRYPOINT <명령>
- 셸 스크립트 구문을 사용할 수 있다.

### 5.2. 셸 없이 바로 실행하기
    ENTRPOINT ["<실행 파일>", "<매개변수1>", "<매개변수2>", ...]
- 실행 파일과 매개변수를 배열 형태로 설정한다.
- CMD와 ENTRYPOINT는 컨테이너가 생성될 때 명령이 실행되는 것은 동일하지만, *dcoker run* 명령에서 동작 방식이 다르다.
  - *dcoker run* 명령에서 실행할 파일을 설정하면, CMD는 무시된다.
    - 즉, *docker run* 명령에서 설정한 <실행할 파일>과 Dockerfile의 CMD는 같은 기능이다.
  - *docker run*에서 실행할 파일을 설정해도 ENTRYPOINT는 무시되지 않고, 실행할 파일 설정 자체를 매개변수로 받아서 처리한다.
- *docker run* 명령에서 *--entrypoint* 옵션을 설정하면, Dockerfile에서 설정한 ENTRYPOINT는 무시된다.

## 6. EXPOSE
    EXPOSE <포트 번호>
- 호스트와 연결할 포트 번호를 설정한다.
- *docker run* 명령의 *--expose* 옵션과 동일하다.
- EXPOSE 하나로 포트 번호를 두개 이상 동시에 설정할 수도 있다.
- EXPOSE는 호스트와 연결만 하고, 외부에는 노출되지 않는다.
  - 포트를 외부에 노출하려면, *docker run* 명령의 *-p* 옵션을 사용해야 한다.

## 7. EVN
    EVN <환경변수> <값>
- 환경변수를 설정한다.
- EVN으로 설정한 환경변수는 RUN, CMD, RNTRYPOINT에 적용된다.
- 환경변수를 사용할 때는 $를 사용한다.
- 환경변수는 *docker run* 명령에서 *-e*나 *--env* 옵션으로도 설정할 수 있다. (둘 다 같음)

## 8. ADD
    ADD <복사할 파일 경로> <이미지에서 파일이 위치할 경로>
- 파일을 이미지에 추가한다.
- <복사할 파일 경로>는 컨텍스트 아래를 기준으로 하며, 컨텍스트의 바깥의 파일, 디렉토리나 절대경로는 사용할 수 없다.
- <복사할 파일 경로>는 파일 뿐만 아니라, 디렉토리도 설정할 수 있으며, 디렉토리를 지정하면 디렉토리의 모든 파일을 복사한다.
  - 와일드카드를 사용하여, 특정 파일만 복사할 수 있다.
    - ex) ADD *.txt/root/
- <복사할 파일 경로>에 인터넷에 있는 파일의 URL을 설정할 수 있다.
  - <이미지에서 파일이 위치할 경로>의 마지막에 /가 있으면 디렉토리가 생성되고, 파일은 그 아래에 복사된다.
- 로컬에 있는 압축 파일은 압축을 해제하고 tar를 풀어서 추가된다.
  - 단, 인터넷에 있는 파일 URL은 압축만 해제한 뒤, tar 파일이 그대로 추가된다.
    - 인터넷에 있는 압축 파일 URL의 압축을 해제하여 추가하려면, RUN으로 *curl*이나 *wget*으로 파일을 받은 뒤, 압축을 해제하면 된다.
- <이미지에서 파일이 위치할 경로>는 항상 절대경로로 설정해야 한다.
  - 마지막이 /로 끝나면 디렉토리가 생성되고, 파일은 그 아래에 복사된다.
- 현재 디렉토리를 추가할 때, .dockerignore 파일에 설정한 파일과 디렉토리는 제외된다.

## 9. COPY
    COPY <복사할 파일 경로> <이미지에서 파일이 위치할 경로>
- 파일을 이미지에 추가한다.
- ADD와는 달리, COPY는 압축 파일을 추가할 때 압축을 해제하지 않고, 파일 URL도 사용할 수 없다.
- 그 외 사용법은 ADD와 동일하다.

## 10. VOLUME
    VOLUME <컨테이너 디렉토리> 또는
    VOLUME ["<컨테이너 디렉토리1>", "<컨테이너 디렉토리2>", ...]
- 디렉토리의 내용을 컨테이너에 저장하지 않고, 호스트에 저장하도록 설정한다.
  - 단, 호스트의 특정 디렉토리와 연결할 수는 없다.
  - 호스트의 특정 디렉토리와 연결하려면 *docker run* 명령에서 *-v* 옵션을 사용해야 한다.

## 11. USER
    USER <계정 사용자명>
- 명령을 실행할 사용자 계정을 설정한다.
- USER 뒤에 오는 모든 RUN, CMD, ENTRYPOINT에 적용된다.
- 중간에 다른 사용자를 설정하여 사용자를 변경할 수 있다.

## 12. WORKDIR
    WORKDIR <경로>
- RUN, CMD, ENTRYPOINT의 명령이 실행될 디렉토리를 설정한다.
- WORKDIR 뒤에 오는 모든 RUN, CMD, ENTRYPOINT에 적용된다.
- 중간에 다른 디렉토리를 설정하여 실행 디렉토리를 변경할 수 있다.
- 절대경로 대신 상대경로도 사용할 수 있다.
  - 상대경로를 사용하면, 먼저 설정한 WORKDIR의 경로를 기준으로 디렉토리를 변경한다.
  - 최초 기준은 /이다.

## 13. ONBUILD
    ONBUILD <Dockerfile 명령> <Dockerfile 명령의 매개변수>
- 생성한 이미지를 기반으로 다른 이미지가 생성될 때 명령을 실행한다.
  - FROM, MAINTAINER, ONBUILD를 제외한 모든 Dockerfile 명령을 사용할 수 있다.
- 최초에 ONBUILD를 사용한 상태에서는 아무 명령도 실행하지 않는다.
- 다음 번에 이미지가 FROM으로 사용될 때 실행할 명령을 예약하는 기능이라 할 수 있다.
- 이미지를 생성한 뒤, 해당 이미지를 기반으로 커스터마이징을 할 때 활용할 수 있다.
- 바로 아래 자식 이미지를 생성할 때만 적용되고, 손자 이미지에는 적용되지 않는다.
  - 즉, 이 설정은 상속되지 않는다.