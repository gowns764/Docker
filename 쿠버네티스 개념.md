# 쿠버네티스 개념

## 1. 쿠버네티스의 특징
1. 모든 리소스는 **오브젝트** 형태로 관리된다.
   - 컨테이너의 집합(Pods), 컨테이너의 집합을 관리하는 컨트롤러(Replica Set), 사용자(service Account), 노드(Node) 등등 하나의 오브젝트로 사용할 수 있다.
   - **kubectl api-resources** 명령어로 쿠버네티스에서 사용할 수 있는 오브젝트들을 확인할 수 있다.
   - 특정 오브젝트에 대한 설명을 보려면 **kubectl expain [오브젝트 이름]** 명령어를 사용한다.
2. 쿠버네티스는 명령어로도 사용할 수 있지만, YAML 파일을 더 많이 사용한다.
   - 쿠버네티스에서 YAML 파일은 컨테이너뿐만 아니라 대부분의 리소스 오브젝트에 사용될 수 있다.
   - 컨테이너 자체, 컨테이너의 설정 값(ConfigMap), 비밀 값(Secrets) 등 모두 YAML 파일로 정의하여 사용한다.
   - 서비스를 배포할 때에도 kubectl 명령어가 아닌 여러 개의 YAML 파일을 정의하여 쿠버네티스에 적용시키는 방식으로 동작한다.
3. 쿠버네티스는 여러 개의 컴포넌트로 구성되어 있다.
   - 쿠버네티스 노드의 역할은 크게 마스터와 워커로 나뉜다.
     - 마스터 노드는 쿠버네티스가 제대로 동작할 수 있게 클러스터를 관리하는 역할을 담당한다.
     - 워커 노드에는 애플리케이션 컨테이너가 생성된다.
   - 쿠버네티스는 도커를 포함한 많은 컴포넌트들이 실행된다.
     - 예를 들어, 마스터 노드에는 API 서버, 컨트롤러 매니저, 스케줄러, DNS 서버 등이 실행된다.
     - 컴포넌트들은 기본적으로 도커 컨테이너로서 실행된다.
     - 쿠버네티스 클러스터 구성을 위해 **kubelet**이라는 에이전트가 모든 노드에서 실행된다.

## 2. 포드(Pod) : 컨테이너를 다루는 기본 단위

### 2.1. 포드 사용하기
- 쿠버네티스에서는 컨테이너 애플리케이션의 기본 단위를 포드(Pod)라고 부르며, 포드는 1개 이상의 컨테이너로 구성된 컨테이너의 집합이다.
- 쿠버네티스의 YAML 파일은 일반적으로 apiVersion, kind, metadata, spec 네 가지 항목으로 구성된다.
  - **apiVersion**
    - YAML 파일에서 정의한 오브젝트의 API 버전을 나타낸다.
  - **kind**
    - 리소스의 종류를 나타낸다.
    - kind 항목에서 사용할 수 있응 리소스 오브젝트 종류는 kubectl api-resources 명령어릐 KIND 항목에서 확인할 수 있다.
  - **metadata**
    - 라벨, 주석, 이름 등과 같은 리소스의 부가 정보들을 입력한다.
  - **spec**
    - 리소스를 생성하기 위한 자세한 정보를 입력한다.
- 작성한 YAML 파일은 **kubectl apply -f [YAML 파일 이름]** 명령어로 쿠버네티스에 생성할 수 있다.
- **kubectl get [오브젝트 이름]** 명령어로 특정 오브젝트의 목록을 확인할 수 있다.
- **kubectl describe [오브젝트 이름]** 명령어로 생성된 리소스의 자세한 정보를 출력할 수 있다.
  - 예를 들어, **kubectl describe pods [포드 이름]** 명령어로 포드의 자세한 정보를 볼 수 있다.
- **kubectl logs [오브젝트 이름]** 명령어로 오브젝트의 표준 출력 로그를 확인할 수 있다.
- **kubectl delete -f [YAML 파일]** 또는 **kubectl delete pod [포드 이름]** 명령어로 오브젝트를 삭제할 수 있다.

### 2.2. 포드 vs 도커 컨테이너
- 포드는 여러 리눅스 네임스페이스를 공유하는 여러 컨테이너들을 추상화된 집합으로 사용한다.
  - 예를 들어, YAML 파일에 컨테이너를 여러 개 작성하고 서버 컨테이너를 실행하지 않아도 다른 컨테이너에서 서버 컨테이너로 접근이 가능하다.
    - 포드 내의 컨테이너들이 네트워크 네임스페이스 등과 같은 리눅스 네임스페이스를 공유하여 사용하기 때문이다.
    - 네트워크 네임스페이스는 컨테이너의 고유한 네트워크 환경을 제공해주는 역할을 한다.

### 2.3. 완전한 애플리케이션으로서의 포드
- 쿠버네티스 환경에서는 1개의 컨테이너로 구성된 포드를 사용하는 경우가 많다.
- 하나의 포드는 하나의 완전한 애플리케이션이다.
- 그러나, 컨테이너가 실행되기 위해 부가적인 기능을 필요로 한다면 기능 확장을 위해 추가 컨테이너를 함께 포드에 포함시킬 수 있다.
  - 포드에 정의된 부가적인 컨테이너를 **사이드카(sidecar) 컨테이너**라고 한다.
  - 사이드카 컨테이너는 포드 내의 다른 컨테이너와 네트워크 환경 등을 공유한다.
  - 때문에 포드에 포함된 컨테이너들은 모두 같은 워커 노드에서 실행된다.

## 3. 레플리카셋(Replica Set) : 일정 개수의 포드를 유지하는 컨트롤러

### 3.1. 레플리카셋을 사용하는 이유
- YAML 파일에에 포드만 정의하여 생성하면 포드를 삭제할 때 그 포드의 컨테이너도 삭제된다.
  - 즉, 이러한 포드는 쿠버네티스 사용자에 의해서만 관리된다.
  - 마이크로 서비스 구조의 포드에서 이러한 방식을 사용하기 어렵다.
    - 여러 개의 동일한 컨테이너를 생성한 뒤 외부 요청이 각 컨테이너에 적절히 분배될 수 있어야 한다.
- 여러 개의 포드를 직접 생성하는 것은 적절하지 않다.
  - 동일한 포드의 개수가 많아질 수록 일일히 YAML 파일에 정의하는 것은 비효율적이다.
  - 포드가 어떠한 이유로든 삭제되거나, 포드가 위치한 노드에 장애가 발생하여 더 이상 포드에 접근하지 못하게 되었을 때, 직접 포드를 삭제하고 다시 생성하지 않는 한 해당 포드는 다시 복구되지 않는다.
- 예를 들어, **kubectl get pods -o wide** 명령어로 포드가 실행 중인 워커 노드를 확인한 뒤, 직접 워커 노드 